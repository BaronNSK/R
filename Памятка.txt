Памятка
1. Чтобы изучить структуру данных воспользуйтесь командой str()

str(mtcars)
2. Чтобы отобрать нужные колонки (переменные) в данных вы можете:

 - использовать номера колонок (не забудьте обернуть индексы в вектор):
mtcars[, c(1, 3, 4)] 

- использовать имена колонок:
mtcars[, c("mpg", "hp")]

3. Чтобы отобрать нужные строки в данных:
mtcars[c(1, 5, 7), ]

Эти приемы можно комбинировать:
mtcars[c(1, 4, 5), c(1, 4)] 

Запомните, сначала идут индексы строк, потом индексы колонок! Также обратите внимание, что мы можем использовать отрицательную индексацию, чтобы отобрать все колонки/строки кроме указанных:
mtcars[, -c(3, 4)] # отберем все строчки и все колонки кроме 3 и 4. 

4. Для более сложных запросов используйте функцию subset():
subset(mtcars, hp > 100 & am == 1)

5. Добавить новую переменную можно при помощи оператора $
mtcars$new_var <- 1:32

6. Чтобы удалить переменную из данных, используйте такую конструкцию:
mtcars$new_var <- NULL

Арифметические операции


+         сложение
-         вычитание
*         умножение
/         деление  (5 / 2 = 2.5)
^ или **  возведение в степень (5^2 = 25 или 5**2 = 25)
x %% y    остаток от деления  (5 %% 2 = 1)
x %/% y   целая часть от деления (5 %/% 2 = 2)

Логические операции


<       меньше 
<=      меньше или равно
>       больше
>=      больше или равно
==      проверка на равенство
!=      не равно
!x      не x
x | y   x или y
x & y   x и y

t-Критерий Стьюдента для независимых выборок:


t.test(Var1 ~ Var2, data) # если первая переменная количественная, а вторая фактор
t.test(data$Var1, data$Var2) # если обе переменные количественные
 t-Критерий Стьюдента для зависимых выборок


t.test(data$Var1, data$Var2, paired = T)
Проверка на нормальность распределения

shapiro.test(Var1) # проверка на нормальность распределения переменной Var1
# но не удобно когда есть группирующая факторная переменная
Поможет функция by(), которая применяет различные функции на каждом уровне фактора.  

by(iris$Sepal.Length, INDICES = iris$Species, shapiro.test) # проверка на нормальность переменной 
# Sepal.Length в трех разных группах в соответствии с переменной Species


Проверка на гомогенность дисперсий:

bartlett.test(mpg ~ am, mtcars) #Критерий Бартлетта 


~ - указвыет зависимость переменной от другой переменной.
x ~ y + z - зависит от двух переменных.
x ~ y:z - зависит от взаимодействия переменных между собой.
x ~ y + z + y:z - и то, и то. - x ~ y * z.
x ~ (y + z + q)^2 - все предикторы взаимодействуют по парам.
x ~ y + Error(subject/y) - несколько повторений на одном предикторе. Если один испытуемый участвует в разных экспериментах, то лучше использовать дисперсионный анализ с Error. aov(z ~ y + Error(x / y)), где z — объясняемая 
переменная, x — та переменная, за счет которой ожидается получить воздействие на объясняющую переменную / переменные 



Памятка по интерпретации результатов регрессионного анализа с категориальными и непрерывными переменными
Модель для примера:
DV ~ IV_numeric * IV_categorical
IV_categorical - фактор с двумя уровнями (Level1 и Level2)
Коэффициенты:
Intercept — предсказанное значение DV для первого уровня IV_categorical с учётом того, что IV_numeric равна нулю.
IV_numeric — насколько изменяется предсказанное значение DV при увеличении IV_numeric на одну единицу в группе, соответствующей первому уровню IV_categorical
IV_categoricalLevel2 — насколько изменяется предсказанное значение DV при переходе от первого уровня IV_categorical ко второму уровню. С учётом того, что IV_numeric равна нулю.
IV_numeric:IV_categoricalLevel2 — насколько сильнее (или слабее) изменяется предсказанное значение DV при увеличении IV_numeric на одну единицу в группе, соответствующей второму уровню IV_categorical, по сравнению с первым уровнем.
Как предсказывать значения в новом датасете на основе полученных коэффициентов
1). Предположим у нас есть новый объект, про который мы знаем, что он принадлежит к группе, соответствующей IV_categorical (Level1) и измеренный у него IV_numeric составил 10:
Предсказанное значение DV = Intercept + 10 * IV_numeric
2). Предположим у нас есть новый объект, про который мы знаем, что он принадлежит к группе, соответствующей IV_categorical (Level2) и измеренный у него IV_numeric составил 6:
Предсказанное значение DV = Intercept + IV_categoricalLevel2 + 6 * (IV_numeric + IV_numeric:IV_categoricalLevel2)


Функции для работы с данными очень часто используются вместе. Предположим, мы хотим отсортировать данные iris по переменной Sepal.Length, при этом оставить только те наблюдения, для которых значения переменной Petal.Length больше 1.7, 
а также оставить только две переменные Sepal.Length и  Petal.Length.

Мы могли бы решить эту задачу следующим образом:

select(arrange(filter(iris, Petal.Length > 1.7), Sepal.Length), Sepal.Length, Petal.Length)
Согласитесь, выглядит слегка громоздко. Проблема в том, что внутри функции select мы используем функции arrange и filter, в результате можно не сразу сообразить, к какой функции принадлежат два последних аргумента, Sepal.Length, 
Petal.Length. Также, несмотря на то, что функция select первая в строчке, мы выполним ее в последнюю очередь только после того, как проведем фильтрацию и сортировку. Таким образом, чтобы разобраться в последовательности операций, 
нам как бы нужно прочитать код в обратном порядке.

Мы могли бы сделать код более читаемым, подчеркнув также порядок действий, создавая промежуточные переменные для каждого этапа:

filtered_iris <- filter(iris, Petal.Length > 1.7)
arranged_iris <- arrange(filtered_iris, Sepal.Length)
selected_iris <- select(arranged_iris, Sepal.Length, Sepal.Width)
Однако, такой подход создает много лишних переменных, которые возможно и не понадобятся нам в дальнейшем.

Специально для решения это проблемы в пакете dplyr есть оператор %>% (Ctrl + Shift + m), при помощи которого можно отправить результат выполнения одной команды в следующую, смотрите, как это работает.

iris %>% 
  filter(Petal.Length > 1.7) %>% 
  arrange(Sepal.Length) %>% 
  select(Sepal.Length, Sepal.Width)
Оператор %>% в прямом смысле слова перетаскивает то, что написано перед ним в качестве аргумента, в следующую функцию. На первом этапе мы отправляем данные iris в функцию filter, в которой теперь достаточно указать только условие фильтрации. Далее результат фильтрации мы отправляем на сортировку по переменной Sepal.Length. И на последнем этапе уже отфильтрованные и отсортированные данные мы отправляем в функцию select, чтобы отобрать нужные колонки.

Результат: код становится более последовательным, мы на каждом этапе видим, какие аргументы в какой функции, прощай забор скобок, не создаем промежуточных переменных.

Такая запись, возможно, является слегка экзотической, и если ваш коллега не пользуется dplyr, то такой код может ввести его в замешательство. Однако к %>% быстро привыкаешь, особенно в контексте dplyr.


my_df[1] - получим dataframe

my_df[[1]] - получим вектор

my_df[, 1] - получим вектор


Давайте рассмотрим один небольшой пример работы с функцией mapply. Я оговорился, что она довольно специфична, однако иногда она все-таки оказывается довольно полезной.

Допустим у нас есть матрица размером 100 на 200:

m <- matrix(rnorm(100 * 200), nrow = 100)
И мы хотим присвоить имена строчкам и столбикам в этой матрице по принципу:


row_1, row_2, row_3, ..., row_100 - для строк

col_1, col_2, col_3, ..., col_200 - для колонок

Тогда мы могли бы сгенерировать список данными именами следующим образом:

> m_names <- mapply(paste, list("row", "col"), list(1:100, 1:200), sep = "_")
> str(m_names) List of 2 
$ : chr [1:100] "row_1" "row_2" "row_3" "row_4" ... 
$ : chr [1:200] "col_1" "col_2" "col_3" "col_4" ...


