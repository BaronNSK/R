df(is.na[df]) <- mean(df, na.rm = T) - заменит пропущенные значения на средние значения.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

my_na_rm <- function(x){             - создаст функцию, которая будет заменять пропущенные значения на средние.
  x[is.na(x)] <- mean(x, na.rm = T)
  return(x)
}


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function(x){                         - создаст функцию, которая будет проверять, нормальное ли распределене и в случае нормальности заменять пропущенные значения на средние, а в случае ненормальности на медиану.
  if(is.numeric(x)){		     								(и выдавать сообщение о том, на что заменили)
    stat_test <- shapiro.test(x)
    if(stat_test$p.value > 0.05){
      x[is.na(x)] <- mean(x, na.rm = T)
      print('NA values were replaced with mean')
    }
    else{
      x[is.na(x)] <- median(x, na.rm = T)
      print('NA values were replaced with median')
    }
    return(x)
  }
  else{
    print('X is not numeric')
  }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

filtered.sum <- function(x){   - создаст функцию, которая вернёт сумму только положительных значений.
  a <- x[x > 0]
  return(sum(a, na.rm = T))


outliers.rm <- function(x){
  x[x > as.numeric(quantile(x, probs = 0.25, na.rm = T)) - 1.5 * IQR(x, na.rm = T) & x < as.numeric(quantile(x, probs = 0.75, na.rm = T)) + 1.5 * IQR(x, na.rm = T)]	- создаст функцию, которая удаляет выбросы и пустые значения.
  return(x)
}


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

filtered.sum <- function(x){   - создаст функцию, которая вернёт сумму только положительных значений.
  a <- x[x > 0]
  return(sum(a, na.rm = T))
}


outliers.rm <- function(x){
  x[x > as.numeric(quantile(x, probs = 0.25, na.rm = T)) - 1.5 * IQR(x, na.rm = T) & x < as.numeric(quantile(x, probs = 0.75, na.rm = T)) + 1.5 * IQR(x, na.rm = T)]	- создаст функцию, которая удаляет выбросы и пустые значения.
  return(x)
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

regr.calc <- function(x){
  test <- cor.test(x[[1]], x[[2]])
  if (test[3] < 0.05){
    reg <- lm(x[[1]] ~ x[[2]])
    x$fit <- reg$fitted.values	
    return(x)
  }else {
    return("There is no sense in prediction")
  }
}                                                  - создаёт функцию, которая на вход получает dataframe c двумя переменными.Если две переменные значимо коррелируют (p - уровень значимости для коэффициента корреляции Пирсона меньше 0.05),
то функция строит регрессионную модель, где первая переменная - зависимая, вторая - независимая. Затем создает в dataframe новую переменную с назанием fit, где сохраняет предсказанные моделью значения зависимой переменной. В результате 
функция возвращает исходный dataframe с добавленной новой переменной fit. Если две переменные значимо не коррелируют, то функция возвращает строчку "There is no sense in prediction"


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
fill_na <- function(x){
  x_1 <- x[[1]]
  x_2 <- x[[2]]
  y <- x[[3]]
  model <- lm(y ~ x_1 + x_2)
  x$y_full <- ifelse(is.na(x$y), predict(model, x), x$y)
  return(x)
}                                                          - создаёт функцию, которая принимает на вход данные с тремя переменными. Строит регрессионну модель. Создаёт в датафрейме новую переменную, в которую сохраняет переменную y, где
отсутствующие значения заменены на предсказанные значения построенной модели.


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

beta.coef <- function(x){
  q <- scale(x[[1]])
  w <- scale(x[[2]])
  e <- lm(q ~ w, x)
  return(e$coefficients)
}                          - создаст функцию, которая на вход получает dataframe с двумя количественными переменными, а возвращает стандартизованные коэффициенты для регрессионной модели, в которой первая переменная датафрейма 
выступает в качестве зависимой, а вторая в качестве независимой.


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

NA_position <- function(x, y){
  all(is.na(x) == is.na(y))
}                                   - функция, возвращающая TRUE, если позиции NA в обоих векторах совпадают или пропущенных значений вообще нет, и значение FALSE, если позиции NA в векторах не совпадают.  


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
smart_test <- function(x){
  x <- table(x)
  if (min(x) < 5){
    return(fisher.test(x)$p.value)
  }
  else{
    chi <- chisq.test(x)
    return(c(chi$statistic, chi$parameter, chi$p.value))
  }
}                                  - функция, которая получает на вход dataframe с двумя номинативными переменными с произвольным числом градаций. Функция должна проверять гипотезу о независимости этих двух переменных при помощи 
критерия хи - квадрат или точного критерия Фишера.Если хотя бы в одной ячейке таблицы сопряженности двух переменных меньше 5 наблюдений, функция должна рассчитывать точный критерий Фишера и возвращать вектор из одного элемента: 
получившегося p - уровня значимости.Если наблюдений достаточно для расчета хи-квадрат (во всех ячейках больше либо равно 5 наблюдений), тогда функция должна применять критерий хи-квадрат и возвращать вектор из трех элементов: 
значение хи-квадрат, число степеней свободы,  p-уровня значимости.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

outliers_count <- function(x){
  outliers <- x[abs(x - mean(x)) > 2 * sd(x)]
  if (length(outliers) > 0){
    return(outliers)
  }
  else{
    return("There are no outliers")
  }
}                                        - создаст функцию, которая будет указывать данные, которые отклоняются от среднего больше, чем на два стандартных отклонения.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

my_list <- list()                           = function(x) {
for (i in seq_along(d)) {                     	x[x < 0]
  temp_col <- d[, i]                          }
  neg_nubers <- temp_col[temp_col < 0]
  my_list[[i]] <- neg_nubers
}                                        - создаёт код, который показывает отрицательные значения в столбцах.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

norm_test <- apply(iris[, 1:4], 2, function(x) shapiro.test(x)$p.value) - проведёт тест на нормальность распределения для четырёх столбцов iris и вернёт p.value.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

na_rm <- function(x){
  replace <- function(x){
    x[is.na(x)] <- mean(x, na.rm = T)
    return(x)
  }
  a <- apply(x, 2, replace)
  return(as.data.frame(a))
}                                      - функция, которая заменяет все пропущенные значения в столбцах dataframe на соответствующее среднее значение. Для каждого столбца на его средние.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

positive_sum <-  function(x){
  q <- function(x){
    x[is.na(x)] <- 0
    return(sum(x[x > 0]))
  }
  lapply(x, q)
}                              - получает на вход dataframe с произвольным количеством числовых переменных. Основная задача функции - найти сумму положительных значений в каждой переменной и сохранить их в список.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

my_names <- function (dataset, names){
  q <- sapply(names, function(x) grepl(x, dataset[, 1]))
  dataset[apply(q, 1, any),]
}                                                          - в процессе проверки на вход вашей функции будет подаваться два аргумента:1. Датафрейм, c произвольным количеством строк, где имена генов сохранены в переменной names (фактор)  в формате ****@name , а уровень экспрессии в переменной expression.
2. Вектор с именами генов, для которых мы хотим отобрать наблюдения. Гарантируется, что имена указанные в векторе есть в данных. Функция возвращает датафрейм с наблюдениями только для указанных генов.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

smart_lm <- function(x){
  q <- sapply(x[-1], function(y) shapiro.test(y)$p.value > 0.05)
  if (all(q == FALSE)) {
    return('There are no normal variables in the data')
  }else{
    z <- x[-1][q == T]
    df <- data.frame(x[[1]], z)
    reg <- lm(x[[1]] ~ ., df[-1])
    return(reg$coefficient)
  }
}                                      -smart_lm, которая получает на вход data.frame с произвольным числом количественных переменных. Первая колонка в данных - это зависимая переменная, все остальные - предикторы.
Функция возвращает в виде вектора коэффициенты линейной регрессии построенной только для отобранных предикторов (условие нормальности распределения). Если таких предикторов в данных не оказалось, то функция 
возвращает предупреждение "There are no normal variables in the data".  качестве предикторов мы хотим использовать только те переменные, распределение которых значимо не отличается от нормального 
(p - value теста Шапиро - Уилка больше 0.05).

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

one_sample_t <- function(test_data, general_mean){
  q <- sapply(test_data, is.numeric)
  w <- test_data[q]
  e <- lapply(w, function(y) c(t.test(y, mu = general_mean)$statistic, t.test(y, mu = general_mean)$parameter, t.test(y, mu = general_mean)$p.value))
  return(e)
}                               - one_sample_t, которая получает на вход два аргумента: 1. Dataframe произвольного размера с произвольным числом переменных различного типа. 2. Числовое значение среднего в генеральной совокупности.
Ваша функция должна применять одновыборочный t - test к каждой числовой переменной в данных, и сравнивать среднее значение этой переменной с указанным значением среднего в генеральной совокупности (второй аргумент функции).
Функция должна возвращать список, где каждый элемент это вектор, состоящий из t - значения, числа степеней свобод (df) и значения p - value.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

get_p_value <- function(test_list){
  sapply(test_list, function(x) x[2])
}                                         - get_p_value, которая получает на вход список (назовем его главным списком), каждый элемент этого списка тоже список - результат выполнения функции shapiro.test . 
Ваша задача из каждого элемента главного списка вытащить только p - value. В итоге функция возвращает список где каждый элемент - одно значение - p - value (как в примере normality_tests_p).

subset(diamonds, 1:nrow(diamonds)%%2 == 1) - выдаст только нечётные строчки данных diamonds.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

log_transform <- function(test_data){
  res <- mutate_if(test_data, is.numeric, funs((. - min(.)) / (max(.) - min(.)) + 1))
  return(mutate_if(res, is.numeric, funs(log(.))))
}                                                  - получает на вход dataframe  с произвольным числом переменных разных типов. На первом этапе функция должна выполнить предобработку числовых переменных. Т.к. значение логарифма мы 
можем рассчитать только для положительных чисел. Проводим центрирование всех переменных (Rescaling), только еще добавим единичку, чтобы у нас не осталось нулей.После того как мы масштабировали каждую переменную, осталось рассчитать 
значение натурального логарифма каждого наблюдения (функция log) и вернуть новый dataframe. 

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

descriptive_stats <- function (dataset){
  gr <- group_by(dataset, gender, country)
  summarise(gr, n = n(), mean = mean(salary, na.rm = T), sd = sd(salary, na.rm = T), median = median(salary, na.rm = T), first_quartile = 
              quantile(salary, probs = 0.25, na.rm = T), third_quartile = quantile(salary, probs = 0.75, na.rm = T), na_values = 
              sum(is.na(salary)))
}                                           - В ситуации, когда у нас есть несколько факторов все наши наблюдения разбиваются на столько групп, сколько возможно комбинации уровней факторов. Например, если у нас есть данные, 
где количественная переменная - размер зарплаты, а два фактора это пол (мужчины и женщины) и национальность (англичане и французы), то два эти фактора разбивают наблюдения на четыре группы:  мужчины французы, женщины француженки, 
мужчины англичане и женщины англичанки.  В общем число всех возможных групп равняется произведению числа градацией факторов.
И так, ваша задача будет написать функцию descriptive_stats, которая рассчитывает основные описательные статистики в каждой группе наблюдений для описанного выше примера. Функция получает на вход dataframe с тремя переменными salary - 
значение заработной платы, gender - фактор с двумя градациями (male, female), country - фактор с двумя градациями (England, France).
Функция должна возвращать dataframe с описательными статистиками и количеством NA, рассчитанными в каждой группе: количеств наблюдений,﻿ среднее значение, стандартное отклонение, медиана, первый квартиль, третий квартиль, число 
пропущенных значений.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

to_factors <- function(test_data, factors){
  q <- test_data
  fact <- q[factors]
  return(mutate_at(q, colnames(fact), funs(as.factor(ifelse(. > mean(.), 1, 0)))))
}                                                                                    - to_factors, которая получает на вход dataframe  с произвольным числом количественных переменных и вектор с номерами колонок, которые нужно перевести 
в фактор. Для перевода числовых колонок в фактор будем использовать следующий принцип, если наблюдение больше среднего всей переменной то 1, иначе 0.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

system.time({              - позволяет узнать, за сколько времени были прочитаны данные.
  for (i in seq_len(5)) {
    fread('products.csv')
  }
})

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

filter.expensive.available <- function(products, brands) {
  products[price >= 5000 & brand %in% brands & available[available = T]]
}                                                                              - принимает на вход products (объект типа data.table) и вектор названий брендов, и возвращает только те строчки, которые соответствуют товарам, цена 
которых больше или равна 5000 рублей, доступны на складе, и принадлежат одному из переданных брендов.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

fix_data <- function(d){
  q <- sapply(d, function(x) grepl('[A-Z]', x))
  a <- function(x){
    as.numeric(gsub(' ', '', x))
  }
  s <- as.data.frame(sapply(d, a))
  s[(is.na(s) == T)] <- d[q]
  z <- sapply(s, function(x) grepl('[A-Z]', x))
  s[z == F] <- as.numeric(s[z == F])
  s
}                                              -  функцию fix_data, которая получает на вход набор данных, у которого в некоторых значениях числовых переменных добавлен пробел между цифрами. Ваша задача - избавиться от этого пробела и 
вернуть числовым переменным их числовой тип. ﻿Функция должна возвращать преобразованный набор данных, в котором все числовые переменные будут переведены в числовой тип

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

as.data.frame(mutate_if(test_data, grepl('[A-Z]', test_data) == F, funs(as.numeric(gsub(' ', '', .))))) - тоже самое, что и предыдущая функция, но для библиотеки dplyr.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

library(data.table)
get_id <- function(data_list){
  df <- as.data.frame(do.call(rbind, data_list))
  id <- df['id']
  sap <- sapply(id, function(x) table(x) == 7)
  t <- which(sap == T)
  as.data.table(data_list)[order(id)][id %in% t][, .(mean_temp = mean(temp)), by = id]
}                                                                    - пациенты неделю измеряют температуру, но не все из них каждый день. Функция возвращает среднюю температуру только тех пациентов, которые измеряли каждый день.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

data <- read.csv('data.csv')
reg <- glm(admit ~ rank * gpa, data,  family = 'binomial')
data$predict <- predict(reg, data, type = 'response')
data['admit']
data$go <- ifelse(data$predict > 0.4, 1, 0)
q <- subset(data, is.na(admit))
sum(subset(q, go == 1)['go'])                              - По имеющимся данным в переменной admit постройте логистическую регрессионную модель, предсказывающую результат поступления по престижности учебного заведения среднего 

образования (переменная rank, 1 — наиболее престижное, 4 — наименее престижное) и результатов GPA (переменная gpa) с учётом их взаимодействия. Примените эту модель к той части данных, где результат поступления неизвестен.
Ответом в задаче будет предсказанное моделью число поступивших из тех, для кого результат поступления был неизвестен. Считаем человека поступившим, когда вероятность его поступления не меньше 0.4.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

get_negative_values <- function(test_data){
  q <- sapply(test_data, function(x) na.omit(x))
  w <- sapply(q, function(x) x[x < 0])
  w[sapply(w, length) > 0]
}                                                - уберёт значения NA и выдаст только отрицательные значения.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

find_outliers <- function(t){                      - факторные переменные делят наблюдения на группы на пересечении градаций этих факторов. задача — создать в данных новую числовую переменную is_outlier, которая будет принимать значение 
  fact <- names(which(sapply(t, is.factor)))       1, если наблюдение в этой строке является выбросом в своей группе, и 0, если не является.Под выбросами будем понимать наблюдения, отклоняющиеся от среднего значения в группе более чем на 
  num <- names(which(sapply(t, is.numeric)))        два стандартных отклонения этой группы.
  t %>% group_by(.dots = fact) %>% 
    mutate_each(is_outlier = (.dots = num), funs(ifelse(abs(. - mean(.)) > 2 * sd(.), 1, 0)))
}